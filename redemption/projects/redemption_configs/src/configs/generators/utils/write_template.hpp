/*
*   This program is free software; you can redistribute it and/or modify
*   it under the terms of the GNU General Public License as published by
*   the Free Software Foundation; either version 2 of the License, or
*   (at your option) any later version.
*
*   This program is distributed in the hope that it will be useful,
*   but WITHOUT ANY WARRANTY; without even the implied warranty of
*   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
*   GNU General Public License for more details.
*
*   You should have received a copy of the GNU General Public License
*   along with this program; if not, write to the Free Software
*   Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
*
*   Product name: redemption, a FLOSS RDP proxy
*   Copyright (C) Wallix 2010-2016
*   Author(s): Jonathan Poelen
*/

#pragma once

#include <iostream>
#include <iomanip>
#include <string>

#include <cstring>


namespace cfg_generators
{

struct io_prefix_lines
{
    char const * s;
    char const * prefix;
    char const * suffix;
    unsigned space;

    friend std::ostream & operator<<(std::ostream & out, io_prefix_lines const & comment)
    {
        if (auto s = comment.s) {
            auto const prefix_size = strlen(comment.prefix);
            while (*s) {
                auto s_point = s;
                for (; *s && '\n' != *s; ++s) {
                }
                out << std::setw(int(comment.space + prefix_size)) << comment.prefix;
                out.write(s_point, s - s_point);
                if (*s == '\n') {
                    ++s;
                }
                out << comment.suffix << '\n';
            }
        }
        return out;
    }
};

inline io_prefix_lines cpp_comment(char const * s, unsigned space) {
    return io_prefix_lines{s, "// ", "", space};
}

inline io_prefix_lines cpp_comment(std::string const & str, unsigned space) {
    return cpp_comment(str.c_str(), space);
}

inline io_prefix_lines cpp_doxygen_comment(char const * s, unsigned space) {
    return io_prefix_lines{s, "/// ", " <br/>", space};
}

inline io_prefix_lines cpp_doxygen_comment(std::string const & str, unsigned space) {
    return cpp_doxygen_comment(str.c_str(), space);
}

inline io_prefix_lines python_comment(char const * s, unsigned space) {
    return io_prefix_lines{s, "# ", "", space};
}

inline io_prefix_lines python_comment(std::string const & str, unsigned space) {
    return python_comment(str.c_str(), space);
}


struct io_chex
{
    char c;

    friend std::ostream & operator<<(std::ostream & out, io_chex const & h)
    {
        int
        c = (h.c >> 4);
        c += (c > 9) ? 'A' - 10 : '0';
        out << char(c);
        c = (h.c & 0xf);
        c += (c > 9) ? 'A' - 10 : '0';
        out << char(c);
        return out;
    }
};


struct io_hexkey
{
    char const * s;
    std::size_t n;
    char const * prefix = "";
    char const * suffix = "";

    friend std::ostream & operator<<(std::ostream & out, io_hexkey const & hk)
    {
        for (const char * k = hk.s, * e = k + hk.n; k != e; ++k) {
            out << hk.prefix << io_chex{*k} << hk.suffix;
        }
        return out;
    }
};


struct io_quoted2
{
    char const * s;

    io_quoted2(char const * s) : s(s) {}
    io_quoted2(std::string const & str) : s(str.c_str()) {}

    friend std::ostream & operator<<(std::ostream & out, io_quoted2 const & q)
    {
        if (auto s = q.s) {
            for (; *s; ++s) {
                if ('\'' == *s || '"' == *s || '\\' == *s) {
                    out << '\\';
                }
                out << *s;
            }
        }
        return out;
    }
};

struct io_replace
{
    char const * s;
    char from;
    char to;

    io_replace(char const * s, char from, char to) : s(s), from(from), to(to) {}
    io_replace(std::string const & str, char from, char to) : io_replace(str.c_str(), from, to) {}

    friend std::ostream & operator<<(std::ostream & out, io_replace const & r)
    {
        if (auto s = r.s) {
            for (; *s; ++s) {
                out << (r.from == *s ? r.to : *s);
            }
        }
        return out;
    }
};

struct io_upper
{
    char const* s;

    friend std::ostream& operator<<(std::ostream& out, io_upper const& u)
    {
        for (char const * s = u.s; *s; ++s) {
            char c = *s;
            out << char(('a' <= c && c <= 'z') ? c - 'a' + 'A' : c);
        }
        return out;
    }
};

constexpr char const* do_not_edit =
    "DO NOT EDIT THIS FILE BY HAND -- YOUR CHANGES WILL BE OVERWRITTEN\n"
    "\n"
;

}
